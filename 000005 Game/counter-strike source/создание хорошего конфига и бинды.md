пожалуй всё что нужно для создания своего собственного конфига для игры, а также различные бинды и пресеты

[Ссылка на статью](https://steamcommunity.com/sharedfiles/filedetails/?id=2200784065)

что это такое?

это руководство по созданию **своего личного конфига для Counter-Strike: Source**. вместо того чтобы копировать всё подряд, что постят другие пользователи - лучше разобраться как работают квары, как устроен конфиг, какой у всего этого синтакс, и самолично написать конфиг, который подходил бы к твоему стилю игры и ПК  
  
в этом руководстве ты найдёшь:  

- глоссарий, объясняющий что такое "cvars", "bind", "alias" и другие термины  
    
- различные готовые бинды, которые можно использовать в конфиге (и на их основе написать свои)  
    
- примеры того как работают бинды  
    
- не-исчерпывающий перечень различных кваров  
    
- графические пресеты, и тд

  
содержимое этого руководство частично будет работать и для Counter-Strike: Global Offensive и для Team Fortress 2, нужно лишь учитывать что в этих играх другие квары  
  

> if you want to thank me...
> 
> ...then check my guide **about fixing various game issues**: _launching, crashing, optimization, stuttering, gamepads_, etc. the guide is huge, but the topic is broad to begin with  
> [![](https://steamuserimages-a.akamaihd.net/ugc/777366107076335701/62F1AED65A6D10F7AE911A580B4CA857AB74305F/?imw=88&imh=88&ima=fit&impolicy=Letterbox&imcolor=%23000000&letterbox=true)
> 
> 101: fixing any game issues 
> 
> Руководство по Steam
> 
> Автор: rarestMeow
> 
> the game doesn't work right? try that ~huge~ troubleshooting guide
> 
> 
> 
> ](https://steamcommunity.com/sharedfiles/filedetails/?id=1935376439)

если что-то сломалось...

> **если игра ведёт себя странно, имеются баги, глюки, визуальные ошибки** (например после того как были применены какие-то cvars), то сделай следующее:  
> 
> - удали файл  
>     
>     ...steam\steamapps\common\Counter-Strike Source\cstrike\cfg\config.cfg
>     
> - очисти содержимое файла:  
>     
>     ...steam\steamapps\common\Counter-Strike Source\cstrike\cfg\autoexec.cfg
>     
> 
> - после этого 90% ошибок в клиенте будут исправлены

глоссарий: cvars, autoexec, bind, alias, 1

cvar

**cvar (console variable)** (квар) это выполняемая команда. как правило квар имеет несколько значений, например  

- "sv_cheats" это квар активирующий читы. он может иметь следующие зачения:  
    
    sv_cheats "0" // читы выключены sv_cheats "1" // читы включены
    
- "cl_dynamiccrosshair" это квар делающий прицел динамичным (меняет размер когда персонаж двигается или стреляет). он может иметь следующие значения:  
    
    cl_dynamiccrosshair "0" // выключен cl_dynamiccrosshair "1" // меняется размер при стрельбе и беге cl_dynamiccrosshair "2" // меняется размер только при беге cl_dynamiccrosshair "3" // меняется размер только при стрельбе
    

выполнить (запустить) квары можно в консоли или через "autoexec" файл (см ниже)  
  
список всех доступных кваров можно посмотреть [здесь](steam://openurl/https://developer.valvesoftware.com/wiki/List_of_CS:S_Cvars)  
  

autoexec

**autoexec** это файл, куда можно скопировать квары и они будут автоматически исполняться каждый раз когда запускается игра  
  
этот файл расположен в следующей папке (если файла "autoexec" там нет, то создай его самостоятельно):  

...steam\steamapps\common\Counter-Strike Source\cstrike\cfg\autoexec.cfg

  
если две формы записи: или на одной строке пишется один квар:  

r_rootlod "0" mat_queue_mode "2" mat_queue_report "0"

  
на одной строке пишется несколько кваров разделяемых знаком ";":  

r_rootlod "0"; mat_queue_mode "2"; mat_queue_report "0"

  
внутри "autoexec" можно оставлять комментарии, например чтобы помнить какой квар за что отвечает. комментарии оставляется после знака "//", например:  

cl_playerspraydisable "1" // отключает спреи игроков // нужно для хорошего пинга: cl_lagcompensation "1"; cl_smooth "1"

  

bind

**bind** (бинд) - функция позволяющая назначить исполнение квара на какую-то кнопку. синтакс выглядит вот так:  

bind "КНОПКА" "КВАР(Ы) или ФУНКЦИЯ"

  
например:  

- bind "N" "net_graph 2" - открывает панель Net-Graph по нажатию кнопки "N"  
    
- bind "KP_5" "buy vesthelm; buy defuser" - покупает "Бронежилет и шлем" и "Дефузер" по нажатию кнопки "Numpad-5"  
    
- bind "TAB" "incrementvar cl_interp 0.01 0.1 0.0025" - меняет ЛЕРП с "0.01" по 0.1" с шагом 0.0025 по нажатию кнопки "TAB"

  
большинство кнопок имеют простые названия: "Q", "W", "E", "1", "2", "3"; но некоторые кнопки имеют специальное, менее очевидное, название:  
  
**NUMPAD**  

( / ) KP_SLASH

( * ) KP_MULTIPLY

( - ) KP_MINUS

( 7 ) KP_HOME

( 8 ) KP_UPARROW

( 9 ) KP_PGUP

( + ) KP_PLUS

( 4 ) KP_LEFTARROW

( 5 ) KP_5

( 6 ) KP_RIGHTARROW

( 1 ) KP_END

( 2 ) KP_DOWNARROW

( 3 ) KP_PGDN

( Enter ) KP_ENTER

( 0 ) KP_INS

( . ) KP_DEL

  
**СПЕЦ-КНОПКИ**  

( Insert ) INS

( Home ) HOME

( Page Up ) PGUP

( Delete ) DEL

( End ) END

( Page Down ) PGDN

  

( стрелка вверх ) UPARROW

( стрелка влево ) LEFTARROW

( стрелка вниз ) DOWNARROW

( стрелка вправо ) RIGHTARROW

  
**МЫШКА**  

( левая кнопка) MOUSE1

( правая кнопка) MOUSE2

( средняя кнопка, колёсико* ) MOUSE3

( прокрутка вниз ) MWHEELDOWN

( прокрутка вверх ) MWHEELUP

( четвёртая кнопка ) MOUSE4

( пятая кнопка ) MOUSE5

* оффтоп: никогда не обращал внимание как смешно звучит слово "колёсико"?  
  

toggle

**toggle** (тагл) - это функция позволяющая переключать значение квара. синтакс выглядит вот так:  

toggle КВАР ЗНАЧ#1"ЗНАЧ#2 ЗНАЧ#3...

  
если у квара есть только значения "0" и "1"то тогда их можно не писать  
  
примеры:  

- bind "V" "toggle voice_scale 0 0.25 0.5 0.7" - переключает громкость голосовых сообщений между 0%-25%-50%-100% по нажатию кнопки "V"  
    
- bind "L" "toggle cl_righthand" - переключает оружие с правой руки в левую по нажатию кнопки "L" (мы не пишем "0" или "1", потому что это единственные значения этого квара)

  

incrementvar

**incrementvar** - функция позволяющая увеличивать значение квара с определённым шагом. синтакс выглядит вот так:  

incrementvar КВАР НАЧАЛЬНОЕ_ЗНАЧ КОНЕЧНОЕ_ЗНАЧ ШАГ

  
примеры:  

- bind "TAB" "incrementvar cl_interp 0.01 0.1 0.0025" - меняет значение ЛЕРП с "0.01" на 0.1" с шагом 0.0025 по нажатию кнопки "TAB"  
    
- bind "INS" "incrementvar net_graph 0 3 1" - меняет режима панели Net-Graph по нажатию кнопки "INSERT"

  

alias

**alias** (алиас) - функция позволяющая назначить исполнение квара(ов) на переменную. синтакс выглядит вот так:  

alias НАЗВАНИЕ "КВАР(Ы) или ДРУГОЙ_АЛИАС"

  
пример:  

alias crosshair_red "cl_crosshaircolor_r 255; cl_crosshaircolor_g 0; cl_crosshaircolor_b 0" alias crosshair_green "cl_crosshaircolor_r 0; cl_crosshaircolor_g 255; cl_crosshaircolor_b 0" alias crosshair_blue "cl_crosshaircolor_r 0; cl_crosshaircolor_g 0; cl_crosshaircolor_b 255" bind "J" crosshair_red bind "K" crosshair_green bind "L" crosshair_blue

этот код позволяет менять цвет прицела на красный/зелёный/синий по нажатию кнопок "J", "K" и "L"  
  
можно подумать что алиас бестолковая функция, но её потенциал раскрывается когда создаются комбинации из нескольких алиасов заменяющих друг-друга. например:  

alias buffer crosshair_red; alias crosshair_red "cl_crosshaircolor_r 255; cl_crosshaircolor_g 0; cl_crosshaircolor_b 0; alias buffer crosshair_green" alias crosshair_green "cl_crosshaircolor_r 0; cl_crosshaircolor_g 255; cl_crosshaircolor_b 0; alias buffer crosshair_blue " alias crosshair_blue "cl_crosshaircolor_r 0; cl_crosshaircolor_g 0; cl_crosshaircolor_b 255; alias buffer crosshair_red" bind "J" buffer

этот код позволяет менять цвет прицела на красный/зелёный/синий по нажатию одной кнопки "J". он работает следующим образом:  

- мы создаём алиас "buffer" и назначаем на него алиас "crosshair_red"  
    
- мы нажимаем кнопку "J" и вызываем алиас "buffer", тот в свою очередь вызывает алиас "crosshair_red"  
    
- алиас "crosshair_red" делает прицел красным и назначает на алиас "buffer" новый алиас "crosshair_green"  
    
- мы нажимаем кнопку "J" и вызываем алиас "buffer", тот в свою очередь вызывает алиас "crosshair_green"  
    
- алиас "crosshair_green" делает прицел зелёным и назначает на алиас "buffer" новый алиас "crosshair_blue"  
    
- мы нажимаем кнопку "J" и вызываем алиас "buffer", тот в свою очередь вызывает алиас "crosshair_blue"  
    
- алиас "crosshair_blue" делает прицел синим и назначает на алиас "buffer" новый алиас "crosshair_red", тем самым формируя (и замыкая) петлю

  

действия

**действия** это различные команды которые может выполнять игрок, например:  

forward (вперёд) back (назад) moveleft (влево) moveright (вправо) jump (прыжок) duck (присесть) speed (шаг) use (использовать) drop (бросить) impulse 100 (фонарь) impulse 201 (спрей) radio1 radio2 radio3 (радио-команды) menuselect 1-9 (выбор под-опции) attack (стрельба) attack2 (альт-режим) reload (перезарядка) invnext (след-предмет) invprev (пред-предмет) lastinv (последний предмет) slot1 slot2 slot3 slot4 slot5 slot6 slot7 slot8 slot9 slot10 (слот предметов) nightvision (ночное зрение) buymenu buyequip (режимы покупки) buy (купить) autobuy (авто-покупка) rebuy (купить последнее) buyammo1 buyammo2 (купить патроны) showscores (счёт) showbriefing (брифинг) chooseteam (выбор команды) pause (пауза)

глоссарий: cvars, autoexec, bind, alias, 2

wait

**wait** это особая функция, которая выжидает (останавливается) на определённое количество тиков перед тем как исполнить следующий квар. её синтакс:  

wait ТИК

  
тик это промежуток времени, зависящий от текущего количества кадров в секунду. к примеру "wait 15" при 100 фпс будет выжидать меньше времени чем "wait 15" при 60 фпс. это значит что при использовании этой функции нужно проверять какое значение подходит именно для твоего пк  
  
wait чаще всего используется, когда нужно убедиться что анимация окончена прежде чем исполнять следующую команду  
  

плюс и минус (+ -)

**плюс и минус (+ -)** это специальные модификаторы, позволяющие выполнять квар или другую функцию когда кнопка зажата (+) и когда она отпущена (-)  
  
**пример #1**:  

alias +slowmo "host_timescale 0.2" alias -slowmo "host_timescale 1" bind "Q" +slowmo

этот код позволяет замедлять время когда кнопка "Q" зажата ("+slowmo") и восстанавливает время на нормальное когда кнопка "Q" отпущена ("-slowmo")  
  
**пример #2**:  

alias +jumpDuck" +jump; +duck;" alias -jumpDuck" -jump; -duck;" bind "ALT" +jumpDuck

этот код позволяет игроку прыгать и приседать одновременно по нажатию кнопки "ALT"  
  
примечание: мы не пользуемся кодом ниже, потому что в таком случае персонаж будет прыгать и приседать без остановки:  

bind "ALT" +jump; +duck;

бинды, 1

быстрая покупка оружия и экипировки

можно создать бинд, позволяющий быстро покупать различные предметы. полный перечень всего добра, что можно купить, представлен ниже:  

пистолеты: "glock" (9x19mm Sidearm) "usp" (KM .45 Tactical) "p228" (228 Compact) "fn57" (ES Five-Seven) "elite" (.40 dual elites) "deagle" (night hawk .50c) СМГ/ПП: "mac10" (Ingram MAC-10) "tmp (Schmidt Machine Pistol) "mp5" (KM Sub-Machine Gun) "ump45 (KM UMP45) "p90" (ES C90) винтовки: "galil" (IDF Defender) "ak47" (CV-47) "sg552" (Krieg 552) "famas" (Clarion 5.56) "m4a1" (M4A1 Carbine) "aug" (Bullpup) снайперки: "g3sg1" (D3/AU-1) "sg550" (Krieg 550 Commando) "scout" (Schmidt Scout) "awp" (Magnum Rifle) дробовики: "m3" (Leone 12 Gauge Super) "xm1014" (Leone YG1265 Auto Shotgun) прочее: "m249" (M249) гранаты: "flashbang" (световая граната) "smokegrenade" (дымовая граната) "hegrenade" (граната) экипировка: "vest" (бронежилет) "vesthelm" (бронежилет и шлем) "defuser" (дефузер) "nvgs" (очки ночного видения)

  
пример полного бинда для покупки различных предметов; задействует спец-кнопки и Numpad:  

bind "KP_INS" "buy vesthelm; buy vest; buy defuser" bind "KP_DEL" "buy hegrenade; buy flashbang; buy flashbang; buy smokegrenade" bind "KP_ENTER" "buy vesthelm; buy vest; buy hegrenade; buy flashbang; buy defuser; buy flashbang; buy smokegrenade" bind "KP_END" "buy awp" bind "KP_DOWNARROW" "buy mp5navy" bind "KP_PGDN" "buy famas; buy galil" bind "KP_LEFTARROW" "buy scout" bind "KP_5" "buy p90" bind "KP_RIGHTARROW" "buy aug; buy sg552" bind "KP_PLUS" "buy m4a1; buy ak47" bind "KP_HOME" "buy usp" bind "KP_UPARROW" "buy glock" bind "KP_PGUP" "buy deagle" bind "KP_SLASH" "buy m3" bind "KP_MULTIPLY" "buy xm1014" bind "KP_MINUS" "buy g3sg1; buy sg550"

  

отправка радио команд

можно создать бинд, позволяющий отправлять радио сообщения по нажатию одной кнопки  
  
вставь следующий код в autoexec:  

alias clear "slot10; wait 5; slot10" alias +r_coverme "radio1; menuselect 1" alias -r_coverme "clear" alias +r_youtakethepoint "radio1; menuselect 2" alias -r_youtakethepoint "clear" alias +r_holdthisposition "radio1; menuselect 3" alias -r_holdthisposition "clear" alias +r_regroup "radio1; menuselect 4" alias -r_regroup "clear" alias +r_followme "radio1; menuselect 5" alias -r_followme "clear" alias +r_takingfire "radio1; menuselect 6" alias -r_takingfire "clear" alias +r_go "radio2; menuselect 1" alias -r_go "clear" alias +r_fallback "radio2; menuselect 2" alias -r_fallback "clear" alias +r_sticktogether "radio2; menuselect 3" alias -r_sticktogether "clear" alias +r_getinposition "radio2; menuselect 4" alias -r_getinposition "clear" alias +r_stormthefront "radio2; menuselect 5" alias -r_stormthefront "clear" alias +r_reportin "radio2; menuselect 6" alias -r_reportin "clear" alias +r_roger "radio3; menuselect 1" alias -r_roger "clear" alias +r_enemyspotted "radio3; menuselect 2" alias -r_enemyspotted "clear" alias +r_needbackup "radio3; menuselect 3" alias -r_needbackup "clear" alias +r_sectorclear "radio3; menuselect 4" alias -r_sectorclear "clear" alias +r_inposition "radio3; menuselect 5" alias -r_inposition "clear" alias +r_reportingin "radio3; menuselect 6" alias -r_reportingin "clear" alias +r_itsgonnablow "radio3; menuselect 7" alias -r_itsgonnablow "clear" alias +r_negative "radio3; menuselect 8" alias -r_negative "clear" alias +r_enedown "radio3; menuselect 9" alias -r_enemydown "clear"

  
затем забинди нужные команды на нужные кнопки:  

bind "" +r_roger // roger that bind "" +r_negative // negative bind "" +r_coverme // cover me bind "" +r_followme // follow me bind "" +r_go // go-go-go bind "" +r_stormthefront // storm the front bind "" +r_takingfire // taking fire, need assistance bind "" +r_needbackup // need backup bind "" +r_enemyspotted // enemy spotted bind "" +r_enemydown // enemy down bind "" +r_holdthisposition // hold this position bind "" +r_inposition // I am in position bind "" +r_sticktogether // stick together, team bind "" +r_regroup // regroup, team bind "" +r_fallback // team, fall back bind "" +r_reportin // report in, team bind "" +r_reportingin // reporting in bind "" +r_sectorclear // sector clear bind "" +r_youtakethepoint // you take the point bind "" +r_getinposition // get in position and wait for my go bind "" +r_itsgonnablow // it's gonna blow!

  

режимы стрельбы

можно создать бинд, позволяющий стрелять с любого оружия в полу-автоматическом режиме, 2-бёрст режиме и 3-бёрст режиме. **режимы бёрст стрельбы, однако, будут немного лагать**, потому что реальная скорость стрельбы (вернее паузы между выстрелами) будет зависеть от количества кадров в секунду  
  
вставь следующий код в autoexec:  

alias w_modeSemiAuto w_modeSemiAuto_ON; alias w_modeSemiAuto_ON "bind mouse1 w_modeSemiAuto_DO; alias w_modeSemiAuto w_modeSemiAuto_OFF;" alias w_modeSemiAuto_DO "+attack; wait 15; -attack;" alias w_modeSemiAuto_OFF "bind mouse1 +w_modeRegular; alias w_modeSemiAuto w_modeSemiAuto_ON;" alias w_mode2BurstFire w_mode2BurstFire_ON; alias w_mode2BurstFire_ON "bind mouse1 w_mode2BurstFire_DO; alias w_mode2BurstFire w_mode2BurstFire_OFF;" alias w_mode2BurstFire_DO "+attack; wait 15; -attack; +attack; wait 15; -attack;" alias w_mode2BurstFire_OFF "bind mouse1 +w_modeRegular; alias w_mode2BurstFire w_mode2BurstFire_ON;" alias w_mode3BurstFire w_mode3BurstFire_ON; alias w_mode3BurstFire_ON "bind mouse1 w_mode3BurstFire_DO; alias w_mode3BurstFire w_mode3BurstFire_OFF;" alias w_mode3BurstFire_DO "+attack; wait 15; -attack; +attack; wait 15; -attack; +attack; wait 15; -attack;" alias w_mode3BurstFire_OFF "bind mouse1 +w_modeRegular; alias w_mode3BurstFire w_mode3BurstFire_ON;" alias +w_modeRegular "+attack"; alias -w_modeRegular "-attack";

  
затем забинди нужные команды на нужные кнопки:  

bind "" w_modeSemiAuto; // переключение между обычным режимом и полу-автоматическим bind "" w_mode2BurstFire; // переключение между обычным режимом и 2-бёрст bind "" w_mode3BurstFire; // переключение между обычным режимом и 3-бёрст

  
внутри кода выше надлежит отредактировать значение "wait" согласно среднему количеству кадров в секунду; также подумай над тем чтобы дать себе какой-то индикатор того какой режим работает в настоящий момент (может окрашивать прицел в определённый цвет?)  
  

отмена нулевого движения (null-cancel)

когда ты нажимаешь одновременно "A" и "D", то персонаж перестаёт двигаться и останавливается на месте. данный бинд позволяет сделать так, чтобы персонаж продолжал движение согласно той кнопке которая была нажата последней  
  
вставь следующий код в autoexec:  

alias m_empty "" alias +m_nullCancelMovementForward "-back; +forward; alias m_nullCancelMovementForwardT +forward" alias -m_nullCancelMovementForward "-forward; m_nullCancelMovementBackwardT; alias m_nullCancelMovementForwardT m_empty" alias +m_nullCancelMovementBackward "-forward; +back; alias m_nullCancelMovementBackwardT +back" alias -m_nullCancelMovementBackward "-back; m_nullCancelMovementForwardT; alias m_nullCancelMovementBackwardT m_empty" alias m_nullCancelMovementBackwardT m_empty alias m_nullCancelMovementForwardT m_empty alias +m_nullCancelMovementLeft "-moveright; +moveleft; alias m_nullCancelMovementLeftT +moveleft" alias -m_nullCancelMovementLeft "-moveleft; m_nullCancelMovementRightT; alias m_nullCancelMovementLeftT m_empty" alias +m_nullCancelMovementRight "-moveleft; +moveright; alias m_nullCancelMovementRightT +moveright" alias -m_nullCancelMovementRight "-moveright; m_nullCancelMovementLeftT; alias m_nullCancelMovementRightT m_empty" alias m_nullCancelMovementLeftT m_empty alias m_nullCancelMovementRightT m_empty bind "W" +m_nullCancelMovementForward bind "S" +m_nullCancelMovementBackward bind "A" +m_nullCancelMovementLeft bind "D" +m_nullCancelMovementRight

бинды, 2

прыжок с броском гранаты

граната должна быть в руках  

alias "+g_jumpThrowGrenade" "+jump; -attack;" alias "-g_jumpThrowGrenade" "-jump" bind "" +g_jumpThrowGrenade

  

прыжок с приседанием

alias +j_jumpDuck "+jump; +duck;" alias -j_jumpDuck "-jump; -duck;" bind "" +j_jumpDuck

  

баннихоп

bind "MWHEELUP" +jump; bind "MWHEELDOWN" +jump

  

включаемый баннихоп

нажми бинд-кнопку что бы прыгать на колёсико мышки, нажми эту кнопку ещё раз что бы прокручивать оружие на колёсико мышки  

alias j_bunnyHopToggle j_bunnyHop_ON; alias j_bunnyHop_ON "bind MWHEELUP +jump; bind MWHEELDOWN +jump; alias j_bunnyHopToggle j_bunnyHop_OFF;" alias j_bunnyHop_OFF "bind MWHEELUP invprev; bind MWHEELDOWN invnext; alias j_bunnyHopToggle j_bunnyHop_ON;" bind "" j_bunnyHopToggle

  

отмена зума снайперской винтовки

после каждого выстрела из снайперской винтовки прицел (зум) будет убираться. нужно подстроить значение функции "wait" под свой пк  

alias +w_unzoomSniperRifle "+attack; wait 5; invnext; wait 50; lastinv; wait; -attack; wait" bind "" +w_unzoomSniperRifle

  

быстрая атака ножом

удерживай кнопку чтобы достать нож и начать им атаковать. отпусти кнопку и нож уберётся, а персонаж достанет предыдущее оружие  

alias +w_fastKnifeAttack "slot3; +attack2" alias -w_fastKnifeAttack "-attack2; lastinv" bind "" +w_fastKnifeAttack

  

режим беглого огня для полу-автоматического оружия

попробуй использовать этот бинд вместе с Dual Elites ;)  

alias w_rapidFire w_rapidFire_ON; alias w_rapidFire_ON "bind MWHEELUP +attack; bind MWHEELDOWN +attack; alias w_rapidFire w_rapidFire_OFF;" alias w_rapidFire_OFF "bind MWHEELUP invprev; bind MWHEELDOWN invnext; alias w_rapidFire w_rapidFire_ON;" bind "" w_rapidFire

  

говорить "cover me" во время перезарядки

bind "" "+reload; wait 25; radio1; menuselect 1; wait 10; slot10; wait 5; slot10; wait 25; -reload"

  

выбирать различные гранаты на кнопки 4-5-6

bind "4" "use weapon_flashbang" bind "5" "use weapon_hegrenade" bind "6" "use weapon_smokegrenade"

  

режим AFK

персонаж будет стоять на месте и вращаться вокруг  

alias m_afk rm_afk_ON alias m_afk_ON "cl_yawspeed 350; +left; alias m_afk rm_afk_OFF" alias m_afk_OFF "cl_yawspeed 210; -left; alias m_afk rm_afk_ON" bind "" m_afk

  

убирать все декали во время движения

bind "W" "+forward; r_cleardecals" bind "S" "+back; r_cleardecals" bind "A" "+moveleft; r_cleardecals" bind "D" "+moveright; r_cleardecals"

  

фильтровать урон в консоли

этот код позволяет отражать в консоли (выделять) все сообщения о том сколько урона ты нанёс и получил  

con_filter_enable "2"; con_filter_text "Damage"; con_filter_text_out "";

net-graph и budget-panel

net-graph

net-graph это специальная панель, показывающая текущий пинг, ЛЕРП и прочие интернет-показатели. позволяет быстро оценить что не так с твоим соединением и увидеть провалы  
  
вставь следующий код в autoexec:  

net_graph "0" net_graphshowinterp "1" net_graphshowlatency "1" net_graphtext "1" net_graphpos "2" net_scale "8" net_graphheight "64" net_graphproportionalfont "0"

  
затем забинди вызов net-graph на нужную кнопку:  

alias n_NetGraph n_NetGraph_ON; alias n_NetGraph_ON "net_graph 2; alias n_NetGraph n_NetGraph_OFF;" alias n_NetGraph_OFF "net_graph 0; alias n_NetGraph n_NetGraph_ON;" bind "" n_NetGraph

  
или используй вот этот код чтобы net-graph появлялся во время открытия текущего счёта (множество игроков предпочитают такой способ):  

alias +n_NetGraphTab "net_graph 2; +showscores"; alias -n_NetGraphTab "net_graph 0; -showscores"; bind "TAB" "+n_NetGraphTab"

  

budget panel

budget-panel это специальная панель, показывающая текущую нагрузку на видеокарту, сколько памяти потребляет каждый графический модуль и другую отладочную информацию. позволяет быстро оценить что потребляет больше всего ресурсов ПК во время игры  
  
вставь следующий код в autoexec:  

budget_panel_height "600" budget_panel_width "350" budget_panel_y "5" budget_panel_x "5" budget_background_alpha "160" texture_budget_panel_height "300" texture_budget_panel_width "350" texture_budget_panel_y "610" texture_budget_panel_x "5" texture_budget_background_alpha "160" budget_bargraph_background_alpha "10" budget_bargraph_range_ms "11" budget_show_history "1" budget_history_numsamplesvisible "1000" budget_panel_bottom_of_history_fraction "0.15" texture_budget_panel_bottom_of_history_fraction "0.15" budget_history_range_ms "100" budget_show_peaks "1" budget_averages_window "30"

  
затем забинди вызов budget-panel на нужную кнопку:  

alias b_showbudget b_showbudget_ON; alias b_showbudget_ON sv_cheats 1; +showbudget; +showbudget_texture; alias b_showbudget b_showbudget_OFF; alias b_showbudget_OFF sv_cheats 0; -showbudget; +showbudget_texture; alias b_showbudget b_showbudget_ON; bind "" b_showbudget;

пресеты графики (производительности)

здесь ты можешь найти четыре графических пресета для копирования в autoexec. не бойся комбинировать разные части различных пресетов (например взять текстуры из "ультра графики", свето-тени из "высокой графики" и сглаживание из "низкой графики")  
  

низкая графика

// рагдоллы cl_ragdoll_physics_enable 0; ragdoll_sleepaftertime 0; // текстуры mat_picmip 2; mat_filtertextures 0; r_3dsky 0; mat_bumpmap: 0; mat_specular: 0; mat_phong: 0; mat_compressedtextures 1; mat_use_compressed_hdr_textures 1; // детали r_rootlod 2; r_lod 2; lod_TransitionDist -1; r_staticprop_lod 3; r_renderoverlayfragment 0; cl_detaildist 0; cl_detailfade 0; // сглаживание mat_antirm_0; mat_aaquality 0; // фильтрация mat_trilinear 0; mat_forceaniso 1; // свет r_dynamic 0; r_maxdlights 0; r_worldlights 0; r_worldlightmin 0.0038; r_hunkalloclightmaps 1; r_rimlight 0; r_ambientboost 0; r_ambientmin 0; mat_filterlightmaps 0; r_lightaverage 0; mat_disable_lightwarp 1; mat_reducefillrate 1; muzzleflash_light 0; cl_c4dynamiclight 0; r_PhysPropStaticLighting 0; // тени r_shadows 0; r_shadowrendertotexture 0; r_shadowmaxrendered 0; r_flashlightdepthtexture 0; // декали r_decals 0; mp_decals 0; r_decalstaticprops 0; r_drawmodeldecals 0; r_maxmodeldecal 0; r_decal_cullsize 1024; r_decal_cover_count 0; r_decal_overlap_area 1; r_decal_overlap_count 0; // пропы cl_phys_props_enable 0; cl_phys_props_max 0; r_propsmaxdist 1; cl_phys_props_respawndist 3000; cl_phys_props_respawnrate 120; // частицы cl_particle_batch_mode 2; mat_reduceparticles 1; r_drawflecks 0; // вода r_waterforceexpensive 0; r_WaterDrawReflection 0; r_waterforcereflectentities 0; r_WaterDrawRefraction 0; cl_show_splashes 0; r_cheapwaterstart 0; r_cheapwaterend .1; // верёвки r_drawropes 0; rope_rendersolid 0; rope_smooth 0; rope_subdiv 0; rope_collide 0; rope_wind_dist 0; r_ropetranslucent 0; // звук snd_pitchquality 0; snd_disable_mixer_duck 1; snd_async_fullyasync 0; snd_mix_async 0; snd_spatialize_roundrobin 3; // прочее mat_colcorrection_disableentities 1; cl_jiggle_bone_framerate_cutoff 0; hud_achievement_glowtime 0; cl_ejectbrass 0; cl_drawmonitors 0;

  

обычная графика

// рагдоллы cl_ragdoll_physics_enable 1; ragdoll_sleepaftertime 1.5; // текстуры mat_picmip 1; mat_filtertextures 1; r_3dsky 1; mat_bumpmap: 1; mat_specular: 1; mat_phong: 0; mat_compressedtextures 1; mat_use_compressed_hdr_textures 1; // детали r_rootlod 1; r_lod -1; lod_TransitionDist 800; r_staticprop_lod -1; r_renderoverlayfragment 0; cl_detaildist 1200; cl_detailfade 400; // сглаживание mat_antirm_2; mat_aaquality 0; // фильтрация mat_trilinear 1; mat_forceaniso 2; // свет r_dynamic 0; r_maxdlights 0; r_worldlights 0; r_worldlightmin 0.0004; r_hunkalloclightmaps 0; r_rimlight 0; r_ambientboost 0; r_ambientmin 0; mat_filterlightmaps 1; r_lightaverage 0; mat_disable_lightwarp 1; mat_reducefillrate 1; muzzleflash_light 0; cl_c4dynamiclight 1; r_PhysPropStaticLighting 0; // тени r_shadows 1; r_shadowrendertotexture 1; r_shadowmaxrendered 6; r_flashlightdepthtexture 1; // декали r_decals 256; mp_decals 64; r_decalstaticprops 1; r_drawmodeldecals 1; r_maxmodeldecal 10; r_decal_cullsize 128; r_decal_cover_count 4; r_decal_overlap_area 0.4; r_decal_overlap_count 3; // пропы cl_phys_props_enable 0; cl_phys_props_max 0; r_propsmaxdist 1; cl_phys_props_respawndist 3000; cl_phys_props_respawnrate 120; // частицы cl_particle_batch_mode 1; mat_reduceparticles 1; r_drawflecks 1; // вода r_waterforceexpensive 0; r_WaterDrawReflection 1; r_waterforcereflectentities 0; r_WaterDrawRefraction 0; cl_show_splashes 1; r_cheapwaterstart 0; r_cheapwaterend .1; // верёвки r_drawropes 1; rope_rendersolid 1; rope_smooth 0; rope_subdiv 1; rope_collide 0; rope_wind_dist 0; r_ropetranslucent 0; // звук snd_pitchquality 0; snd_disable_mixer_duck 0; snd_async_fullyasync 1; snd_mix_async 1; snd_spatialize_roundrobin 1; // прочее mat_colcorrection_disableentities 0; cl_jiggle_bone_framerate_cutoff 20; hud_achievement_glowtime 0.25; cl_ejectbrass 1; cl_drawmonitors 0;

  

высокая графика

// рагдоллы cl_ragdoll_physics_enable 1; ragdoll_sleepaftertime 3; // текстуры mat_picmip 0; mat_filtertextures 1; r_3dsky 1; mat_bumpmap: 1; mat_specular: 1; mat_phong: 1; mat_compressedtextures 0; mat_use_compressed_hdr_textures 1; // детали r_rootlod 0; r_lod -1; lod_TransitionDist 800; r_staticprop_lod 0; r_renderoverlayfragment 1; cl_detaildist 1200; cl_detailfade 0; // сглаживание mat_antirm_4; mat_aaquality 2; // фильтрация mat_trilinear 1; mat_forceaniso 8; // свет r_dynamic 1; r_maxdlights 6; r_worldlights 4; r_worldlightmin 0.0002; r_hunkalloclightmaps 0; r_rimlight 1; r_ambientboost 1; r_ambientmin 0.5; mat_filterlightmaps 1; r_lightaverage 1; mat_disable_lightwarp 0; mat_reducefillrate 0; muzzleflash_light 1; cl_c4dynamiclight 1; r_PhysPropStaticLighting 1; // тени r_shadows 1; r_shadowrendertotexture 1; r_shadowmaxrendered 18; r_flashlightdepthtexture 1; // декали r_decals 1024; mp_decals 256; r_decalstaticprops 1; r_drawmodeldecals 1; r_maxmodeldecal 25; r_decal_cullsize 32; r_decal_cover_count 4; r_decal_overlap_area 0.4; r_decal_overlap_count 5; // пропы cl_phys_props_enable 1; cl_phys_props_max 20; r_propsmaxdist 900; cl_phys_props_respawndist 3000; cl_phys_props_respawnrate 120; // частицы cl_particle_batch_mode 1; mat_reduceparticles 0; r_drawflecks 1; // вода r_waterforceexpensive 0; r_WaterDrawReflection 1; r_waterforcereflectentities 1; r_WaterDrawRefraction 1; cl_show_splashes 1; r_cheapwaterstart 100; r_cheapwaterend 300; // верёвки r_drawropes 1; rope_rendersolid 1; rope_smooth 1; rope_subdiv 2; rope_collide 0; rope_wind_dist 500; r_ropetranslucent 1; // звук snd_pitchquality 1; snd_disable_mixer_duck 0; snd_async_fullyasync 1; snd_mix_async 1; snd_spatialize_roundrobin 0; // прочее mat_colcorrection_disableentities 0; cl_jiggle_bone_framerate_cutoff 65; hud_achievement_glowtime 0.5; cl_ejectbrass 1; cl_drawmonitors 1;

  

ультра графика

// рагдоллы cl_ragdoll_physics_enable 1; ragdoll_sleepaftertime 3; // текстуры "mat_picmip -1; mat_filtertextures 1; r_3dsky 1; mat_bumpmap: 1; mat_specular: 1; mat_phong: 1; mat_compressedtextures 0; mat_use_compressed_hdr_textures 0; // детали r_rootlod 0; r_lod 0; lod_TransitionDist 800; r_staticprop_lod 0; r_renderoverlayfragment 1; cl_detaildist 3000; cl_detailfade 0; // сглаживание mat_antialias rm_8; mat_aaquality 4; // фильтрация mat_trilinear 1; mat_forceaniso 16; // свет r_dynamic 1; r_maxdlights 32; r_worldlights 4; r_worldlightmin 0; r_hunkalloclightmaps 0; r_rimlight 1; r_ambientboost 1; r_ambientmin 1; mat_filterlightmaps 1; r_lightaverage 1; mat_disable_lightwarp 0; mat_reducefillrate 0; muzzleflash_light 1; cl_c4dynamiclight 1; r_PhysPropStaticLighting 1; // тени r_shadows 1; r_shadowrendertotexture 1; r_shadowmaxrendered 32; r_flashlightdepthtexture 1; // декали r_decals 2048; mp_decals 512; r_decalstaticprops 1; r_drawmodeldecals 1; r_maxmodeldecal 50; r_decal_cullsize 0; r_decal_cover_count 8; r_decal_overlap_area 0.9; r_decal_overlap_count 8; // пропы cl_phys_props_enable 1; cl_phys_props_max 300; r_propsmaxdist 1200; cl_phys_props_respawndist 1500; cl_phys_props_respawnrate 60; // частицы cl_particle_batch_mode 1; mat_reduceparticles 0; r_drawflecks 1; // вода r_waterforceexpensive 1; r_WaterDrawReflection 1; r_waterforcereflectentities 1; r_WaterDrawRefraction 1; cl_show_splashes 1; r_cheapwaterstart 150; r_cheapwaterend 700; // верёвки r_drawropes 1; rope_rendersolid 1; rope_smooth 1; rope_subdiv 7; rope_collide 1; rope_wind_dist 1000; r_ropetranslucent 1; // звук snd_pitchquality 1; snd_disable_mixer_duck 0; snd_async_fullyasync 1; snd_mix_async 1; snd_spatialize_roundrobin 0; // прочее mat_colcorrection_disableentities 0; cl_jiggle_bone_framerate_cutoff 1; hud_achievement_glowtime 0.5; cl_ejectbrass 1; cl_drawmonitors 1;

HUD

основное

cl_software_cursor

какой курсор должен использоваться?  
**0**: стандартный курсор ОС  
**1**: встроенный в игру курсор

-

cl_drawhud

отображать HUD  
**0**: нет  
**1**: да

полезно использовать этот квар если нужно сделать скриншот без деталей интерфейса

cl_c4progressbar

отображать прогресс разминирования C4  
**0**: нет  
**1**: да

-

cl_nowinpanel

показывать MVP в конце раунда (лучший игрок)  
**0**: нет  
**1**: да

-

hud_takesshots

делать скриншот счёта в конце матча  
**0**: нет  
**1**: да

-

cl_drawmonitors

показывать изображения на экранах игровых мониторов  
**0**: да  
**1**: нет

-

  

информация

hud_deathnotice_time

на сколько секунд показывать информацию кто кого убил  
**0-20**: кол-во секунд

-

hud_drawhistory_time

на сколько секунд показывать информацию о подобранном оружии  
**0-20**: кол-во секунд

-

scr_centertime

на сколько секунд показывать уведомления  
**0-20**: кол-во секунд

уведомления это сообщения о том что был переключен режим огня, бомба была заминирована, Т или КТ победили, и др

cl_hudhint_sound

играть звук когда показываются уведомления  
**0**: нет  
**1**: да

-

cl_showpluginmessages

показывать сообщения от серверных плагинов  
**0**: нет  
**1**: да

-

spec_scoreboard

показывать счёт когда ты был убит  
**0**: нет  
**1**: да

-

cl_disablefreezecam

показывать кто тебя убил (камера подъезжает к лицу убийцы и делается стоп-кадр)  
**0**: да  
**1**: нет

-

  

радар

drawradar

показывать радар  
**0**: нет  
**1**: да

-

cl_radaralpha

прозрачность радара  
**0**: полностью прозрачный  
**1-254**: уровень прозрачности  
**255**: полностью не-прозрачный

-

cl_radar_locked

кручение радара  
**0**: радар не крутится когда игрок двигает камеру (стоит на месте)  
**1**: радар крутится когда игрок двигает камеру

-

  

достижения

hud_achievement_tracker

показывать трэкер-достижений (их прогресс в углу экрана)  
**0**: нет  
**1**: да

-

hud_achievement_description

показывать описание достижений в трэкере-достижений  
**0**: нет  
**1**: да

-

hud_achievement_count

сколько достижений отображать в трэкере-достижений  
**0-5**: кол-во достижений

-

hud_achievement_glowtime

сколько секунд достижение должно подсвечиваться когда ты увеличил его прогресс  
**0-10**: кол-во секунд

это свечение может приводить к подвиваниями на некоторых старых видеокартах

cl_show_achievement_popups

показывать эмблемы достижений, когда ты их разблокировал  
**0**: нет  
**1**: да

-

  

оружия

hud_fastswitch

менять оружие без дополнительного клика мышки  
**0**: нет  
**1**: да

-

cl_autowepswitch

авто-переключение на подобранное оружие  
**0**: нет  
**1**: да

-

cl_righthand

в какой руке должно быть оружие  
**0**: в левой  
**1**: в правой

-

cl_wpn_sway_interp

уровень отклонения оружия когда игрок двигает мышкой  
**0**: нет отклонения  
**0.01 - 0.99**: уровень отклонения  
**1**: максимальное отклонение

-

cl_ejectbrass

выпускать гильзы из оружия во время стрельбы  
**0**: да  
**1**: нет

-

  

имя врага

hud_showtargetid

показывать имя врага когда ты целишься в него  
**0**: нет  
**1**: да

-

hud_showtargetpos

где именно показывать имя врага  
**0**: в центре  
**1**: в верхне-левом углу  
**2**: в верхне-правом углу  
**3**: в нижне-левом углу  
**4**: в нижне-правом углу

-

  

модели персонажей

cl_minmodels

использовать одинаковую модель для всех игроков одной команды  
**0**: нет  
**1**: да

позволяет легко отличать друзей и врагов на расстоянии

cl_min_t

использовать следующую модель для всех Т  
**1**: Phoenix Connection  
**2**: Elite Crew  
**3**: Arctic Avengers  
**4**: Guerilla Warfare

-

cl_min_ct

использовать следующую модель для всех КТ  
**1**: Seal Team  
**2**: GSG-9  
**3**: SAS  
**4**: GIGN

-

cl_jiggle_bone_framerate_cutoff

части моделей персонажей будут реалистично подпрыгивать или изгибаться при движении (например грудь или длинные волосы)  
**0**: нет  
**1**: да  
**2-300**: отключать эту опцию если текущее фпс ниже этого значения

модель персонажа должна иметь такие детали, и ни одна из стандартных моделей их не имеет

мышка и прицел

мышка

sensitivity

чувствительность мышки  
**0.0-5.0**: значение

-

m_rawinput

игнорировать ускорение мышки из ОС и со стороны драйверов (raw mouse input)  
**0**: нет  
**1**: да

-

m_customaccel

алгоритм ускорения мышки  
**0**: нет  
**1**: acceleration = min(m_customaccel_max, pow(raw_mouse_delta, m_customaccel_exponent) * m_customaccel_scale + sensitivity)  
**2**: ...тоже самое что и выше, но дополнительно берутся в расчёт m_pitch и m_yaw  
**3**: acceleration = pow(raw_mouse_delta, m_customaccel_exponent - 1) * sensitivity

не работает при "m_rawinput: 1"

zoom_sensitivity_ratio

чувствительность мышки внутри прицела снайперской винтовки (зум)  
**0.0-5.0**: значение

если, например, поставить "0.5", то тогда чувствительность мышки в зуме будет 50% от стандартной

cl_yawspeed

скорость того как быстро персонаж поворачивается влево/вправо (+left/+right)  
**0-1220**: значение

-

cl_pitchspeed

скорость того как быстро персонаж смотрит вверх/вниз (+lookup/+lookdown)  
**0-1220**: значение

-

  

прицел

crosshair

показывать прицел  
**0**: нет  
**1**: да

-

cl_observercrosshair

показывать прицел в режиме наблюдателя  
**0**: нет  
**1**: да

-

cl_crosshairsize

размер прицела  
**0-20**: значение

-

cl_crosshairspreadscale

дальность линий прицела  
**0.0-5.0**: значение

-

cl_crosshairthickness

толщина линий прицела  
**0.0-5.0**: значение

-

cl_dynamiccrosshair

должен ли прицел увеличиваться/уменьшаться при движении и стрельбе (динамичный прицел)  
**0**: нет  
**1**: да, при стрельбе и движении  
**1**: да, только при движении  
**1**: да, только при стрельбе

-

cl_crosshairdot

показывать маленькую точку внутри прицела  
**0**: нет  
**1**: да

-

cl_crosshairusealpha

прозрачность прицела  
**0**: нет  
**1**: да

-

cl_crosshairalpha

уровень прозрачности прицела  
**0**: полностью прозрачный  
**1-254**: уровень прозрачности  
**0**: полностью не-прозрачный

-

cl_crosshaircolor

цвет прицела  
**0**: зелёный  
**1**: красный  
**2**: синий  
**3**: жёлтый  
**4**: циан  
**5**: уникальный

-

cl_crosshaircolor_r

как много красного цвета должно быть в прицеле  
**0**: не должно быть вообще  
**1-254**: кол-во красного цвета  
**255**: максимальный уровень красного цвета

работает только при "cl_crosshaircolor 5"

cl_crosshaircolor_g

как много зелёного цвета должно быть в прицеле  
**0**: не должно быть вообще  
**1-254**: кол-во зелёного цвета  
**255**: максимальный уровень зелёного цвета

работает только при "cl_crosshaircolor 5"

cl_crosshaircolor_b

как много синего цвета должно быть в прицеле  
**0**: не должно быть вообще  
**1-254**: кол-во синего цвета  
**255**: максимальный уровень синего цвета

работает только при "cl_crosshaircolor 5"

  
для "cl_crosshaircolor_r", "cl_crosshaircolor_g" и "cl_crosshaircolor_b" используй различные онлайн-ресурсы чтобы подобрать цвет который будет подходить для твоей игры, например сайт [colorspire](steam://openurl_external/https://steamcommunity.com/linkfilter/?url=https://www.colorspire.com/rgb-color-wheel/)[www.colorspire.com]. я играю с прицелом фиолетового цвета:  

cl_crosshaircolor_r 160; cl_crosshaircolor_g 40; cl_crosshaircolor_b 255;

  
несколько примеров настройки прицела:  

cl_crosshairsize 5; cl_crosshairspreadscale 0; cl_crosshairthickness 0.5; cl_crosshairdot 0; cl_crosshairsize 5; cl_crosshairspreadscale 1; cl_crosshairthickness 0.7; cl_crosshairdot 0; cl_crosshairsize 5.5; cl_crosshairspreadscale 0.3; cl_crosshairthickness 2; cl_crosshairdot 1; cl_crosshairsize 4; cl_crosshairspreadscale 0; cl_crosshairthickness 1; cl_crosshairdot 0; cl_crosshairsize 2; cl_crosshairspreadscale 0.5; cl_crosshairthickness 0.5; cl_crosshairdot 0; cl_crosshairsize 2; cl_crosshairspreadscale 0.5; cl_crosshairthickness 0.9; cl_crosshairdot 0; cl_crosshairsize 4.5; cl_crosshairspreadscale 1; cl_crosshairthickness 0.3; cl_crosshairdot 1; cl_crosshairsize 1; cl_crosshairspreadscale 0; cl_crosshairthickness 4; cl_crosshairdot 0; cl_crosshairsize 0; cl_crosshairspreadscale 0.3; cl_crosshairthickness 1.9; cl_crosshairdot 1; cl_crosshairsize 500; cl_crosshairspreadscale 0.3; cl_crosshairthickness 0.5; cl_crosshairdot 0;

локальный сервер и боты

настройки сервера

mp_roundtime

время на раунд  
**0.0-9.0**: кол-во минут

-

mp_buytime

время на закупку  
**0.0-9.0**: кол-во минут

-

mp_freezetime

сколько секунд в начале раунда никто не может двигаться  
**0-99**: кол-во секунд

-

mp_round_restart_delay

столько секунд должно пройти с окончания раунда прежде чем начнётся новый  
**0-99**: кол-во секунд

-

mp_startmoney

стартовое количество денег  
**800-16000**: значение

-

mp_footsteps

слышать звуки шагов  
**0**: нет  
**1**: да

-

mp_flashlight

разрешить использование фонарика  
**0**: нет  
**1**: да

-

sv_cheats

разрешить читы  
**0**: нет  
**1**: да

-

  

боты

bot_add

добавить бота

-

bot_add_ct

добавить бота для КТ

-

bot_add_t

добавить бота для Т

-

bot_quota

максимальное кол-во ботов в игре  
**0-99**: значение

-

mp_autoteambalance

балансировать кол-во игроков/ботов между командами  
**0**: нет  
**1**: да

-

mp_limitteams

в одной команде может быть на столько больше игроков чем в другой команде  
**0**: отменить эту опцию (в каждой команде может быть сколько угодно игроков)  
**1-99**: значение

-

bot_join_after_player

боты присоединяются после игроков в начале нового матча  
**0**: нет  
**1**: да

-

bot_defer_to_human

боты на спасают заложников и не закладывают/дефузят мины  
**0**: нет  
**1**: да

-

bot_mimic

боты повторяют все команды за игроком  
**0**: нет  
**1**: да

-

отладка (дебаггинг)

cl_showfps

сообщать текущий фпс  
**0**: нет  
**1**: да  
**2**: да, с дополнительными деталями

-

cl_showpos

сообщать текущее положение, скорость и угол обзора  
**0**: нет  
**1**: да

-

cl_showbattery

сообщать информацию о батарее  
**0**: нет  
**1**: да

-

cl_show_num_particle_systems

сообщать кол-во активных частиц  
**0**: нет  
**1**: да

-

snd_show

сообщать какие звуки сейчас играют  
**0**: нет  
**1**: да

-

snd_profile

сообщать какой DPS модель используется (в консоли)  
**0**: нет  
**1**: да

-

snd_async_spew_blocking

сообщать какие звуки загружаются асинхронно (в консоли)  
**0**: нет  
**1**: да

-

cl_showerror

сообщать об общих предугадывания (network-prediction)  
**0**: нет  
**1**: да

-

sv_showimpacts

сообщать текущие попадания и хитбоксы  
**0**: нет  
**1**: да

-

интернет и соединение

рейт и лерп

rate

максимальная скорость загрузки/получения данных с сервера (рейт)  
**0-131000**: значение в байт/секунду (bps)

определи скорость отдачи своего соединения в байт/секунду (bps) и возьми 75% от этого числа. если будут наблюдаться проблемы, то попробуй взять 65% или 85%

cl_cmdrate

максимальное количество пакетов (snapshots) в секунду, которые будут отправляться на сервер  
**20,30,50,66,100**: значение

должно быть тоже самое значение что и тикрейт (tickrate) сервера и обычно это "66". на многих серверах используется модифицированное значение в "100". если твой минимальный фпс ниже этого числа, то могут наблюдаться лаги

cl_updaterate

максимальное количество пакетов (snapshots) в секунду, которые будут приходить с сервера  
**20,30,50,66,100**: значение

должно быть равно "cl_cmdrate"

cl_interp

лерп - количество секунд (миллисекунд) которые клиент тратит на то чтобы подсчитать расположение и статус объектов до того как получит ответ с сервера  
**0**: определять лучшее значение автоматически  
**0.001-1.000**: кол-во секунд

идеально, это значение должно быть как можно ближе к "0" как только возможно (например, "0.0085"), но реальное значение зависит от скорости интернета и характеристик ПК

cl_interp_ratio

использовать ли дополнительный подсчёт данных перед отправкой данных на сервер  
**1**: нет  
**2**: да

в 95% случаев значение должно быть "1", использовать "2" надлежит только тогда когда имеются значительные лаги и рассинхрон

  

коррекция и предугадывание

cl_lagcompensation

исправлять ошибки вызванные рейтом и лерпом  
**0**: нет  
**1**: да

-

cl_smooth

экстра-коррекция (компенсация) ошибок  
**0**: нет  
**1**: да

-

cl_smoothtime

применять коррекцию раз на столько секунд (миллисекунд)  
**0.01-2.00**: значение

-

cl_pred_optimize

алгоритм предугадывания  
**0**: отключить  
**1**: предугадывать если со стороны сервера нет обновлений  
**2**: предугадывать если со стороны сервера нет обновлений и сервер сообщает о расхождении данных

-

cl_predictweapons

предугадывать стрельбу и разброс пуль  
**0**: нет  
**1**: да

-

cl_predict

предугадывать передвижение игроков  
**0**: нет  
**1**: да

-

  

пакеты

net_maxroutable

разделять пакет данных на более мелкие пакеты если его размер превышает это значение  
**576-1260**: значение

-

net_maxfragments

максимально возможный размер одного пакета  
**576-1260**: значение

хорошая идея использовать значение равное "net_maxroutable"

net_compresspackets

сжимать пакеты  
**0**: нет  
**1**: да

-

net_compresspackets_minsize

сжимать пакеты если их суммарный размер больше этого значения  
**0-4096**: значение

хорошая идея использовать значение равное "net_maxroutable" + 1

net_maxpacketdrop

не принимать пакеты если их размер меньше этого значения (мусорные данные)  
**0**: всегда принимать  
**1-15000**: значение

-

net_maxcleartime

максимальное кол-во секунд клиент может выжидать прежде чем отправить следующий пакет  
**0.0-4.0**: кол-во секунд

не рекомендуется использовать значение меньше "0.1" - есть риск лагов

net_splitpacket_maxrate

максимальная скорость отправки/получения пакетов на один фрагмент  
**1000-1048576**: значение

лучше всего использовать значение равное "rate"

  

закачка и отправка

cl_allowdownload

разрешить скачивание файлов с сервера (карты, спреи, модели, звуки...)  
**0**: нет  
**1**: да

-

cl_downloadfilter

какие файлы будут скачиваться с сервера  
**all**: любые файлы  
**mapsonly**: только карты  
**nosounds**: все файлы, кроме звуков  
**none**: никакие файлы

-

net_maxfilesize

не скачивать файлы, если их несжатый размер превышает это значение в МБ  
**0-64**: размер в МБ

-

cl_allowupload

разрешить отправку файлов на сервер (спреи, модели, звуки...)  
**0**: нет  
**1**: да

-

cl_resend

кол-во секунд клиент будет выжидать прежде чем переподключиться к серверу (если пропало соединение)  
**1.5-20**: кол-во секунд

значения ниже "3" иногда могут приводить к крашу игры

cl_timeout

кол-во секунд клиент будет выжидать прежде чем закрыть соединение с сервером (если пропало соединение)  
**0.0-90.0**: кол-во секунд

-

общение и чат

общение

voice_enable

разрешить голосовое общение  
**0**: нет (не слышать голоса других игроков)  
**1**: да (слышать голоса других игроков)

-

voice_modenable

разрешить использование микрофона  
**0**: нет  
**1**: да

voice_forcemicrecord

как именно игра должна определять микрофон  
**0**: игра сама обнаруживает микрофон  
**1**: игра использует тот микрофон который обнаружит ОС

-

cl_mute_all_comms

как опция "заглушить игрока" (mute) должна работать  
**0**: ты не будешь слышать голос этого игрока  
**ф**: ты не будешь слышать голос этого игрока и не будешь получать чат-сообщения от него

-

  

чат

cl_showtextmsg

показывать внутри-игровой чат  
**0**: нет  
**1**: да

-

cl_chatfilters

какие сообщения показывать в чате  
**1**: игрок X вошёл/покинул игру  
**2**: игрок X поменял имя  
**4**: сообщения игроков  
**8**: сообщения сервера  
**16**: игрок X поменял команду  
**32**: разблокированные достижения

это битвайз оператор, а значит числа надлежит сложить друг с другом чтобы создать группу сообщений которые ты хочешь получать. например, если ты хочешь получать "сообщения игроков" и "сообщения сервера" то надо использовать значение "12" (4+8)

hud_saytext_time

через сколько секунд сообщения будут исчезать из чата  
**0-20**: кол-во секунд

-

звук

основное

snd_surround_speakers

тип звуковой системы  
**-1**: определять автоматически  
**0**: наушники  
**1**: 2 колонки  
**2**: 2.1 стерео  
**3**: 2.1 стерео + сабвуфер  
**4**: 4 колонки  
**5**: 5.1 стерео  
**6**: 5.1 стерео + сабвуфер  
**7**: 7.1 стерео

-

volume

громкость  
**0**: выключить звук  
**0.01-0.99**: уровень громкости  
**1**: максимальная громкость

-

snd_musicvolume

громкость музыки  
**0**: выключить музыку  
**0.01-0.99**: уровень громкости  
**1**: максимальная громкость

-

snd_mute_losefocus

как должен вести себя звук в игре когда игра свёрнута ALT-TAB'ом (или находится не в фокусе)  
**0**: звук продолжает играть  
**1**: звук пропадает

-

  

микширование

dsp_enhance_stereo

смешивать левый и правый звуковые каналы  
**0**: нет  
**1**: да

разница между "0" и "1" можно почувствовать с хорошей звуковой картой, если ты не слышишь разницу, то тогда просто используй "1"

snd_disable_mixer_duck

алгоритм микширования звуков  
**0**: микшировать все звуки  
**1**: микшировать только звуки с общего источника

"0" даёт более реалистичный звук, но потребляет больше ресурсов ПК

snd_mixahead

сколько секунд (миллисекунд) должно пройти между звуками чтобы начать их микшировать  
**0.01-0.1**: кол-во секунд

низкое значение может привести к искажениям звукам и щелчкам, высокое значение может привести к задержке звука и хрипам

  

качество

snd_pitchquality

использовать звук высокого качества (интерполированный)  
**0**: нет  
**1**: да

-

dsp_slow_cpu

какой звуковой движок использовать  
**0**: встроенный по-умолчанию в движок Source  
**1**: аналог (реплика) модуля openAL's HRTF

openAL's HRTF работает гораздо быстрее, но звук более глухой. примечательно, некоторые игроки отмечают что эта "глухота" позволяет лучше понимать откуда и на каком расстоянии раздаются звуки (например оценить как далеко бежит враг)

snd_noextraupdate

использовать дополнительные звуковые дорожки для старых ПК  
**0**: да  
**1**: нет

данная опция должна быть включена только на ПК с низкой производительностью

snd_cull_duplicates

что делать с одинаковыми звуками (точнее с дубликатами в soundscape_flush)  
**0**: воспроизводить эти звуки по отдельности  
**1**: воспроизводить только один вариант звука и отбросить дубликаты

значение "1" полезно только для маломощных ПК

  

асинхронизация

snd_async_fullyasync

использовать асинхронизацию звука  
**0**: нет  
**1**: да

будет работать только на мульти-ядерных процессорах

snd_async_minsize

какое количество звуковых данных может быть воспроизведено за раз без асинхронизации  
**0**: отключить эту функцию и асинхронизировать все звуки  
**1-1048576**: кол-во данных

данная опция полезна только для маломощных ПК

snd_mix_async

хранить все звуковые эффекты в отдельном процессорном потоке  
**0**: нет  
**1**: да

лучше всего работает на процессорах с хотя бы 4 потоками

  

спатиализация

snd_spatialize_roundrobin

сколько кадров может быть обработано одним звуковых модулем (DSP) за раз (спатиализация)  
**0**: каждый кадр  
**1**: каждый 2й кадр  
**2**: каждый 4й кадр  
**3**: каждый 8й кадр

значение "0" делает звук куда более насыщенным, но потребляет больше ресурсов ПК, чем реже делается спатиализация, тем меньше расходуется мощности ПК

snd_defer_trace

какой именно кадр надлежит спатиализовать  
**0**: кадр когда начался звук  
**1**: следующий кадр после того как начался звук

значение "1" может помочь с подвиванием звука на слабых ПК, во всех иных случаях должно быть "0"

процессор и видеокарта

поддержка мульти-ядерных процессоров

threadpool_affinity

использовать настройки для мульти-ядерных процессоров  
**0**: нет (игра будет думать что процессор одно-ядерный)  
**1**: да

кроме как ради отладки - нет никакой реальной необходимости использовать значение "0"

mat_queue_mode

каким образом игра должна использовать мульти-ядерный процессор  
**-2**: автоматически определять лучший метод (старый алгоритм, не использовать!)  
**-1**: автоматически определять лучший метод (новый алгоритм)  
**0**: не использовать многопоточность  
**1**: использовать одно ядро под несколько потоков  
**2**: использовать нескольких ядер под несколько потоков

-

host_thread_mode

запускать сессию в мульти-ядерном режиме  
**0**: нет  
**1**: да, если процессор поддерживает это  
**2**: да, даже если процессор не поддерживает это

этот квар очень забагован и лучше его не использовать

r_queued_post_processing

использовать многопоточность для пост-процессинга (размытие, блум, HDR...)  
**0**: нет  
**1**: да

если игра крашится или есть ошибки с текстурами, то используй "0"

r_queued_decals

использовать многопоточность для декалей  
**0**: нет  
**1**: да

может приводить к ошибкам на некоторых видеокартах, лучше использовать "0"

r_queued_ropes

использовать многопоточность для верёвок  
**0**: нет  
**1**: да

-

r_threaded_client_shadow_manager

использовать многопоточность для теней  
**0**: нет  
**1**: да

-

r_threaded_renderables

использовать многопоточность для объектов  
**0**: нет  
**1**: да

может приводить к ошибкам на некоторых видеокартах, лучше использовать "0"

r_threaded_particles

использовать многопоточность для частиц  
**0**: нет  
**1**: да

-

cl_threaded_bone_setup

использовать многопоточность для анимаций  
**0**: нет  
**1**: да

может приводить к ошибкам на некоторых видеокартах, лучше использовать "0"

cl_threaded_client_leaf_system

использовать многопоточность для листьев  
**0**: нет  
**1**: да

может приводить к ошибкам на некоторых видеокартах, лучше использовать "0"

  

предзагрузка

cl_forcepreload

загружать все текстуры и ассеты в VRAM  
**0**: нет  
**1**: да

карты будут загружаться дольше и будет расходоваться больше ресурсов видеокарты, но минимизирует кол-во зависаний и провалов фпс

mat_forcemanagedtextureintohardware

сжимать все данные внутри VRAM  
**0**: нет  
**1**: да

если включать эту опцию, то уменьшится общая нагрузка на видеокарту, но есть вероятность подвисаний

mat_levelflush

очищать VRAM при загрузке новой карты  
**0**: нет  
**1**: да

-

mat_bufferprimitives

очищать примитивы, когда отрисованы меши  
**0**: нет  
**1**: да

это работает следующим образом: сначала берутся примитивы (наборы данных), и по их основе рисуются объекты (меши), после чего на меши накладываются текстуры, и объекты появляется на карте. данный квар позволяет уменьшить нагрузку на видеокарту, путём убирания использованных примитивов, но это может привести к более долгорй загрузке карты

графика: общее

рендер, кадры

r_fastzreject

алгоритм рендеринга (отрисовки)  
**-1**: ПК самостоятельно решает как осуществлять рендерниг  
**0**: весь рендеринг осуществятся процессором  
**1**: процессор осуществляет первую отрисовку кадра, далее отрисовку делает видеокарта

если у тебя быстрый процессор, то используй "0", в противном случае используй "1"; игра может крашится если выбрать неверное значение

r_norefresh

хранить в памяти предыдущий кадр игры  
**0**: нет (меньше нагрузка на видеокарту, больше лагов)  
**1**: да (больше нагрузка на видеокарту, меньше лагов)

на некоторых видеокартах игра может крашиться если выбрать "1"

mat_dxlevel

режим directX  
**80**: directX 8.0  
**81**: directX 8.1  
**90**: directX 9.0  
**95**: directX 9.5

-

fps_max

искусственный ограничитель фпс  
**120**: используй это значение если пользуешься "m_rawinput: 1", ИЛИ если у тебя, в среднем, меньше 300 фпс  
**300**: используй это значение если пользуешься "m_rawinput: 0", ИЛИ если у тебя, в среднем, больше 300 фпс  
**не пользуйся никакими другими значениями**

это не ограничитель фпс, это компенсации между движением мышки и отрисовкой кадра. этот квар не обходи чтобы стабилизировать плавность движения курсора на определенное количество кадров

mat_vsync

вертикальная синхронизация  
**0**: нет  
**1**: да

-

mat_postprocessing_combine

выполнять все пост-процессоры (блум, размывка, фильтрация...) в один заход  
**0**: да  
**1**: нет

-

  

даунсемплинг, апскеил

mat_viewportscale

какой процент от стандартного разрешения фактически использовать  
**0.01-0.99**: значение  
**1**: нормальное разрешение (лучшее, стандартное, качество)

-

mat_viewportupscale

апскеил уменьшенного разрешения  
**0**: да  
**1**: нет

работает только если квар "mat_viewportscale" имеет любое другое значение кроме "1"

  

туман дистанции

r_pixelfog

использовать улучшенный алгоритм для отрисовки тумана на дальней дистанции  
**0**: нет (низкое качество)  
**1**: да (высокое качество)

-

r_pixelvisibility_partial

использовать алгоритм отрисовки частичной видимости сквозь туман  
**0**: нет  
**1**: да

-

  

детализация

r_rootlod

качество моделей  
**0**: высокое  
**1**: среднее  
**2**: низкое

-

r_lod

когда модель находится далеко, то уменьшать её качество до этого значения  
**-1**: определять автоматически  
**0**: высокое  
**1**: среднее  
**2**: низкое

-

lod_TransitionDist

на какой дистанции качество модели начинает уменьшаться  
**-1**: никогда не уменьшать качество моделей  
**0-2048**: дистанция в юнитах

-

r_staticprop_lod

качество недвижимых объектов (камни, деревья, ящики, бочки...)  
**-1**: определять автоматически  
**0**: высокое  
**1**: среднее  
**2**: низкое  
**3**: очень низкое

-

r_drawdetailprops

показывать дополнительные детали у недвижимых объектов  
**0**: нет  
**1**: да

-

cl_detaildist

на какой дистанции дополнительные детали у недвижимых объектов будут показываться  
**0-4098**: дистанция в юнитах

-

cl_detailfade

на какой дистанции дополнительные детали у недвижимых объектов будут исчезать  
**0-4098**: дистанция в юнитах

-

  

рагдоллы

cl_ragdoll_physics_enable

включить рагдоллы для мёртвых тел  
**0**: нет (тела будут исчезать после смерти)  
**1**: да

-

ragdoll_sleepaftertime

сколько секунд будет длиться рагдолл  
**0-5**: кол-во секунд

-

g_ragdoll_fadespeed

как быстро рагдолл отключается (переходит из состояния "рагдолла" в состояние "проп")  
**0-2000**: значение

-

  

текстуры

mat_picmip

качество текстур  
**-1**: высокое  
**0**: среднее  
**1**: низкое  
**2**: очень низкое

-

mat_compressedtextures

использовать сжатые текстуры  
**0**: нет (высокое качество)  
**1**: да (низкое качество)

-

mat_use_compressed_hdr_textures

использовать сжатые текстуры с дополнительными HDR эффектами  
**0**: нет (низкое качество)  
**1**: да (высокое качество)

-

r_3dsky

использовать дополнительные текстуры для окружения и растительности (дома, листья, облака...)  
**0**: нет  
**1**: да

-

r_renderoverlayfragment

использовать дополнительные текстуры на стенах и дорогах (постеры, отметки, следы взрывов...)  
**0**: нет  
**1**: да

-

mat_mipmaptextures

использовать текстуры низкого качества на дальней дистанции  
**0**: да  
**1**: нет

-

mat_filtertextures

размывать текстуры (делать их менее пикселизированными)  
**0**: нет  
**1**: да

-

mat_parallaxmap

добавлять эффект глубины в некоторые текстуры (песок, камень, детали одежды...)  
**0**: нет  
**1**: да

-

mat_clipz

оптимизировать текстуры перед выводом их на экран  
**0**: нет  
**1**: да

кроме как для режима отладки, нет необходимости использовать значение "0"

mat_colorcorrection

использовать алгоритм коррекции цвета для текстур  
**0**: нет  
**1**: да

этот алгоритм расходует мизерное количество ресурсов, нет нужды его отключать

mat_colcorrection_disableentities

использовать расширенный алгоритм коррекции цвета  
**0**: да (высокое качество)  
**1**: нет (низкое качество)

-

  

фильтрация, сглаживание

mat_trilinear

изначальный уровень фильтрации текстур  
**0**: билинейный  
**1**: трилинейный

-

mat_forceaniso

уровень фильтрации текстур  
**0**: отключить фильтрацию текстур  
**1**: 1X  
**2**: 2X  
**4**: 4X  
**8**: 8X  
**16**: 16X

-

mat_antialias

уровень сглаживания  
**0**: отключить сглаживание  
**1**: 1X  
**2**: 2X  
**4**: 4X  
**8**: 8X

-

mat_aaquality

качество сглаживания  
**0**: низкое  
**2**: среднее  
**4**: высокое

-

mat_alphacoverage

качество сглаживания для полу-прозрачных элементов  
**0**: низкое  
**1**: высокое

-

графика: освещение, тени, окклюжен

освещение

r_dynamic

отображать динамичное освещение  
**0**: нет  
**1**: да

-

r_maxdlights

максимальное количество источников динамичного освещения в одном кадре  
**0**: нет (отключить динамичное освещение)  
**1-32**: значение

-

r_lightcache_zbuffercache

использовать расширенную систему освещения  
**0**: нет  
**1**: да

на некоторых ПК "r_lightcache_zbuffercache: 0" может крашить игру

mat_reducefillrate

использовать улучшенный шейдер для отрисовки освещения  
**0**: да  
**1**: нет

-

r_lightaverage

смягчать освещение  
**0**: нет  
**1**: да

-

r_worldlights

использовать следующие источники света  
**0**: никакие  
**2**: простые источники света  
**4**: все источники света

-

r_hunkalloclightmaps

ограничивать уровень освещения с одного источники света  
**0**: нет  
**1**: да

-

mat_filterlightmaps

использовать улучшенное освещение для текстур  
**0**: нет  
**1**: да

-

r_PhysPropStaticLighting

разрешить объектами отбрасывать тень после того как они были подсвечены  
**0**: нет  
**1**: да

-

mat_disable_lightwarp

разрешить нескольким источникам света перекрывать друг-друга  
**0**: да  
**1**: нет

-

r_rimlight

разрешить свету ложиться на модели  
**0**: нет  
**1**: да

-

r_ambientboost

позволить свету отражаться от поверхностей  
**0**: нет  
**1**: да

-

r_ambientmin

минимальное качество отражённого света  
**0**: не отражать свет  
**0.1-1.0**: уровень отражённого света

-

muzzleflash_light

при стрельбе оружие освещает окружение  
**0**: нет  
**1**: да

-

cl_c4dynamiclight

С4 мигает и освещает окружение  
**0**: нет  
**1**: да

-

r_dopixelvisibility

лампы в игре отбрасывают световой конус  
**0**: нет  
**1**: да

-

  

тени, фонарь

r_shadows

отображать тени  
**0**: нет  
**1**: да

-

r_shadowrendertotexture

отображать реалистичные тени от моделей персонажей  
**0**: нет  
**1**: да

-

r_shadowmaxrendered

максимальное количество реалистичных теней  
**0**: нет (отключить реалистичные тени)  
**1-32**: значение

-

r_flashlightrender

отображать свет от фонаря  
**0**: нет  
**1**: да

-

r_flashlightdepthtexture

освещение от фонаря отбрасывает реалистичные тени  
**0**: нет  
**1**: да

-

r_flashlightmodels

отображать дополнительные эффекты фонаря при освещении моделей (блики, гланц...)  
**0**: нет  
**1**: да

-

  

окклюжен

r_occlusion

отображать окклюжен  
**0**: нет  
**1**: да

окклюжен это отрисовка дополнительных теней на углах и складках моделей и текстур для придания им реалистичности

r_occludermincount

количество проходов окклюжена на один предмет  
**1-10**: значение

чем выше число - тем выше качество

r_occludeemaxarea

не использовать окклюжен для больших объектов  
**0**: нет  
**1**: да

-

r_occluderminarea

не использовать окклюжен для маленьких объектов  
**0**: нет  
**1**: да

-

gl_amd_occlusion_workaround

использовать старую версию окклюжена для старых видеокарт AMD  
**0**: нет  
**1**: да

для очень старых видеокарт, где-то 2003-2005 года

графика: размытие, HDR, блум

размытие (блюр)

mat_motion_blur_enabled

разрешить размытие (блюр)  
**0**: нет  
**1**: да

-

mat_motion_blur_percent_of_screen_max

процент экрана который может размываться  
**1-100**: значение

-

mat_motion_blur_strength

интенсивность размытия  
**0-20**: значение

-

mat_motion_blur_rotation_intensity

интенсивность размытия когда персонаж смотрит вокруг  
**0-32**: значение

-

mat_motion_blur_forward_enabled

интенсивность размытия когда персонаж двигается  
**0-32**: значение

-

mat_motion_blur_falling_intensity

интенсивность размытия когда персонаж падает с большой высоты  
**0-32**: значение

-

mat_motion_blur_falling_min

минимальный процент экрана который может размываться когда персонаж падает с большой высоты  
**0-100**: значение

-

mat_motion_blur_falling_max

максимальный процент экрана который может размываться когда персонаж падает с большой высоты  
**0-100**: значение

-

  

HDR, блум

mat_hdr_level

тип освещения/яркости, который будет использоваться  
**0**: LDR (низкое качество)  
**1**: LDR + неотключаемый блум  
**2**: HDR (высокое качество) + отключаемый блум

если ты будешь использовать HDR, то обязательно настрой "mat_non_hdr_bloom_scalefactor" и "mat_bloom_scalefactor_scalar"

mat_autoexposure_max

максимальный уровень освещения когда HDR срабатывает  
**0-20**: значение

-

mat_autoexposure_min

минимальный уровень освещения когда HDR срабатывает  
**0-20**: значение

-

mat_non_hdr_bloom_scalefactor

насколько интенсивным должен быть HDR  
**0.0-20.0**: значение

-

mat_disable_bloom

отображать эффект блум  
**0**: да  
**1**: нет

работает только с квар "mat_hdr_level: 2"

mat_bloomscale

размер эффекта блум  
**0.0-5.0**: значение

-

mat_bloom_scalefactor_scalar

насколько интенсивным должен быть блум  
**0.0-20.0**: значение

-

r_bloomtintr

кол-во красного цвета в эффекте блум  
**0.0-1.0**: значение

-

r_bloomtintg

кол-во зелёного цвета в эффекте блум  
**0.0-1.0**: значение

-

r_bloomtintb

кол-во синего цвета в эффекте блум  
**0.0-1.0**: значение

-

r_bloomtintexponent

насколько более яркими должны быть цвета во время эффекта блум  
**0.0-5.0**: значение

-

графика: декали, пропы, частицы

декали

r_decals

кол-во декалей, отображаемых на карте за раз (дыры от пуль, спреи, кровь, детали карты)  
**0-4096**: значение

-

mp_decals

кол-во декалей, оставленных игроками, отображаемых на карте за раз  
**0-4096**: значение

можно просто указать 1/4 от значения "r_decals"

cl_playerspraydisable

отображать спреи игроков  
**0**: да  
**1**: нет

-

r_spray_lifetime

сколько раундов спреи будет оставаться на месте  
**0-20**: значение

-

r_decal_cullsize

декаль должна быть как минимум такого размера чтобы отображаться  
**0**: убрать любые ограничения  
**1-512**: значение

-

r_drawbatchdecals

отображать декали поэтапно (часть одним потоком, часть другим)  
**0**: нет  
**1**: да

-

r_decalstaticprops

показывать декали на статичных объектах  
**0**: нет  
**1**: да

игра будет использовать дополнительные настройки света для этого

r_drawmodeldecals

показывать декали на моделях персонажей  
**0**: нет  
**1**: да

-

r_maxmodeldecal

максимальное количество декалей на одной модели  
**0**: не отображать детали на моделях  
**1-4096**: значение

не может быть выше чем "mp_decals"

r_decal_cover_count

кол-во декалей которые могут отображаться поверх друг-друга  
**0**: новая декаль перезаписывает декаль под ней  
**1-8**: значение

-

r_decal_overlap_count

сколько декалей, за один раз, могут перекрывать другую декаль  
**0**: новая декаль перезаписывает декаль под ней  
**1-8**: значение

-

r_decal_overlap_area

какой процент декали должен быть перекрыт другими декалями чтобы эта декаль окончательно исчезла  
**0**: новая декаль перезаписывает декаль под ней  
**0.01-1.00**: значение

-

  

пропы

cl_phys_props_enable

использовать отдельный под-движок для подсчёта того как будут вести себя пропы  
**0**: нет  
**1**: да

проп это любой физический объект с которым игрок может взаимодействовать, например бочки или кружки

cl_phys_props_max

кол-во пропов, обрабатываемых движком  
**0-500**: значение

-

cl_phys_props_respawnrate

сколько раз за единицу времени движок отрисовывает позицию пропа  
**0-128**: значение

-

props_break_max_pieces

кол-во деталей (фрагментов) пропа, обрабатываемых движком  
**-1**: все фрагменты (стандартное значение модели)  
**0-100**: значение

-

func_break_max_pieces

тоже самое что и "props_break_max_pieces", только работает с другим видом пропов на некоторых старых картах  
**0-100**: значение

не может быть "-1"

props_break_max_pieces_perframe

кол-во деталей (фрагментов) пропа, обрабатываемых движком в одном кадре  
**-1**: все фрагменты (стандартное значение модели)  
**0-100**: значение

-

cl_phys_props_respawndist

дистанция, когда детали (фрагменты) пропа убираются с карты если находятся вне поля зрения игрока  
**0**: никогда не убирать фрагменты с карты  
**1-5000**: дистанция в юнитах

-

r_propsmaxdist

дистанция, когда детали (фрагменты) пропа не обрабатываются движком  
**0**: фрагменты всегда будут обрабатываться движком  
**1-5000**: дистанция в юнитах

-

  

частицы

cl_particle_batch_mode

использовать улучшенный алгоритм для управления частицами (лучше качество)  
**0**: нет  
**1**: да

mat_reduceparticles

уменьшить кол-во частиц  
**0**: нет  
**1**: да

эта опция не даёт прироста производительности при "cl_particle_batch_mode: 1"

cl_new_impact_effects

использовать улучшенные эффекты вхождения пуль в плотные поверхности  
**0**: нет  
**1**: да

на некоторых старых ПК использование "1" может привести к исчезновению всех частиц

r_drawflecks

отрисовывать ошмётки (например когда пуля входит в стену)  
**0**: нет  
**1**: да

-

графика: вода и верёвки

вода

r_waterforceexpensive

использовать высоко-качественный шейдер для воды  
**0**: нет  
**1**: да

-

r_WaterDrawReflection

разрешить отражения воды  
**0**: нет  
**1**: да

-

r_waterforcereflectentities

использовать улучшенный алгоритм (высокое качество) для отражений воды  
**0**: нет  
**1**: да

-

r_WaterDrawRefraction

разрешить искажение изображения когда персонаж погружается под воду  
**0**: нет  
**1**: да

карта должна поддерживать такой эффект. значение "0" может крашить игру на некоторых старых видеокартах

cl_show_splashes

показывать всплески воды  
**0**: нет  
**1**: да

-

r_forcewaterleaf

оптимизировать качество/производительность водных эффектов  
**0**: нет  
**1**: да

нет никакого смысла пользоваться значением "0", разве только для дебаггинга

r_cheapwaterstart

дистанция когда начинает отрисовываться "дешёвая вода" (см. ниже)  
**0-2048**: дистанция в юнитах

-

r_cheapwaterend

дистанция когда "дешёвая вода" перестаёт отрисовываться и начинает отрисовываться "пустая вода"  
**0-2048**: дистанция в юнитах

в игре есть три вида воды: обычная (к ней применяются все эффекты), "дешёвая" (к ней не применяется ряд эффектов) и "пустая" (к ней практически не применяются эффекты и она только для декорации). если вода находится в пределе зрения игрока, то она не может быть "пустой", даже если превышает установленную дистанцию

  

верёвки

r_drawropes

отрисовывать верёвки (кабели, линии лэп...)  
**0**: нет  
**1**: да

-

rope_rendersolid

использовать расширенный алгоритм отрисовки верёвок (лучше качество)  
**0**: нет  
**1**: да

-

rope_averagelight

использовать расширенный алгоритм отрисовки освещения на верёвках (лучше качество)  
**0**: нет  
**1**: да

-

rope_smooth

сглаживать верёвки (избавление от угловатостей)  
**0**: нет  
**1**: да

-

rope_subdiv

при сглаживании верёвки разделять её на такое количество под-верёвок и сглаживать их по отдельности  
**0**: не разделять верёвку  
**1-7**: кол-во под-верёвок

-

rope_smooth_enlarge

при сглаживании верёвка уменьшается в размере, данный квар позволяет искусственно увеличить верёвку  
**0**: не увеличивать верёвку  
**0.1-2.0**: значение

правильное значение зависит от разрешения монитора, но в среднем значение "1.4" подойдёт для большинства игроков

rope_collide

разрешить верёвкам взаимодействовать с окружением  
**0**: нет  
**1**: да

-

rope_wind_dist

дистанция когда ветер перестаёт взаимодействовать с верёвками  
**0**: ветер не взаимодействует с верёвками  
**1-1000**: дистанция в юнитах

-

r_ropetranslucent

резрешить полупрозрачность верёвкок  
**0**: нет  
**1**: да

-

не включай в конфиг следующие квары

это перечень кваров, которые очень часто появляются в различных конфигах в Интернете, и которые, по факту, не несут практической пользы. некоторые из них устарели и были заменены другими кварами, некоторые просто бессполезные, некоторые портят игру. **не пользуйся ими**  
  

mp_usehwmmodels  
mp_usehwmvcds

часто приписывается что они "улучшают качество графики". эти квары используются в Team Fortress 2 и не несут никакой пользы в CSS

r_eyes  
r_flex  
r_teeth  
r_eyemove  
r_eyegloss  
r_eyeshift_x  
r_eyeshift_y  
r_eyeshift_z  
r_eyesize  
blink_duration

эти квары ответственны за лицевую анимацию и не работают в CSS (зато работают в Team Fortress 2)

nb_shadow_dist

из-за слова "shadow" ("тень") можно подумать что этот квар имеет отношение к теням, но в действительность этот квар отвечает за нахождение пути в игре Team Fortress 2

violence_ablood  
violence_agibs

эти квары из игры Half-Life

g_ragdoll_maxcount  
g_ragdoll_important_maxcount

эти квары из игры Half-Life 2

tracer_extra  
r_drawtracers_firstperson

в CSS нет трейсеров пуль, а значит эти квары бесполезны

r_drawviewmodel  
r_drawviewmodel  
viewmodel_fov

в CSGO viewmodel работает, да, но не работает в CSS

cl_radartype  
cl_locationalpha

устаревшие квары из CS16

cl_crosshairscale  
cl_scalecrosshair  
cl_legacy_crosshair_scale  
cl_legacy_crosshair_recoil

устаревшие квары из CS16

mat_shadowstate

квар перестал работать после одного из патчей (устарел)

windows_speaker_config

квар перестал работать после одного из патчей (устарел)

r_flashlightrendermodels

квар перестал работать после одного из патчей (поломан)

fast_fogvolume

квар перестал работать после одного из патчей (поломан. и поломан, к слову, уже почти 14 лет)

r_maxnewsamples  
r_maxsampledist

квар никогда не работал (в 2008 году был патч который "вроде как" его исправил, но квар как был сломан - так и остался)

cl_ragdoll_collide

квар перестал работать после одного из патчей (поломан)

cl_interp_all  
cl_interp_npcs

различные конфиги рекомендуют их изменить каким-то образом для улучшения качества соединения - но это заблуждение

sv_forcepreload

часто пишется что он улучшает соединение, но это не так - это серверный квар и он просто не может работать на пк пользователей

mat_envmapsize  
mat_envmaptgasize

иногда сообщается что они улучшают производительность игры, но в действительности эти квары нужны для дебаггинга

rope_smooth_maxalpha  
rope_smooth_minalpha  
rope_smooth_maxalphawidth  
rope_smooth_minwidth

различные квары, связанные с верёвками, которые якобы, влияют на производительность. нет, не влияют. они влияют лишь на отрисовку (внешний вид) верёвок

cl_detail_max_sway  
cl_detail_avoid_radius  
cl_detail_avoid_force  
cl_detail_avoid_recover_speed

тоже самое что и выше, но для детализации

dsp_mix_max  
dsp_room  
dsp_spatial  
dsp_speaker  
dsp_vol_2ch  
dsp_vol_4ch  
dsp_vol_5ch  
dsp_volume  
dsp_water  
dsp_off

часто упоминается что эти квары могут как-то улучшить качество звука, но в действительности они отвечают за DSP-модули, накладывающие определённые эффекты на звук и не могут никоим образом улучшить его качество, а вот вызвать его щелчки или скрипы они могут

snd_duckerthreshold  
snd_duckerreleasetime  
snd_duckerattacktime  
voice_steal

упоминает что эти квары улучшают звук в Windows 8/10, но это заблуждение

mat_dxlevel "100", "110"

да, "mat_dxlevel" это реально-существующий (и работающий) квар, но у него нет значений "100" и "110", которые, как ошибочно утверждается, активируют режимы DirectX 10 и 11

threadpool_affinity "2", "4", "8"

в некоторых конфигах пишется, что этому квару нужно присвоить значение равно кол-ву ядер процессора ("2", "4", "8"), но это заблуждение: квар поддерживает только два значения - "0" и "1"

mat_picmip "3"

в некоторых конфигах этому квару присваивается значение "3" (для активации "супер-низкого качества"), но это заблуждение. этот квар не поддерживает значение "3" и более того, иронично, при присвоении ему неверного значения, квар сбрасывается обратно "0" (стандартное значение), а оно означает "нормальная графика"

mat_wateroverlaysize

этот квар работает во многих играх на движке Source, но не в CSS. вернее, он работает, но не так как должен. квар должен ухудшать/улучшать качество отражения воды, но полной функции для этого нет. вместо этого игра просто обрабатывает (готовит) нужное кол-во сэмплов для подсчёта отражения воды и ничего с ними в итоге не делает

mat_max_worldmesh_vertices

ты знаешь что такое вертикальные-меши? если нет, то зачем тогда пытаешься редактировать этот квар? а если знаешь, то задай сам себе вопрос как их редактирование может изменить хоть что-то в твоей игре?